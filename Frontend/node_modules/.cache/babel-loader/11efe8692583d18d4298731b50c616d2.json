{"ast":null,"code":"const util = require(\"./util\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst naclUtil = require(\"tweetnacl-util\");\n\nfunction encrypt(pusher, channel, data) {\n  if (pusher.config.encryptionMasterKey === undefined) {\n    throw new Error(\"Set encryptionMasterKey before triggering events on encrypted channels\");\n  }\n\n  const nonceBytes = nacl.randomBytes(24);\n  const ciphertextBytes = nacl.secretbox(naclUtil.decodeUTF8(JSON.stringify(data)), nonceBytes, pusher.channelSharedSecret(channel));\n  return JSON.stringify({\n    nonce: naclUtil.encodeBase64(nonceBytes),\n    ciphertext: naclUtil.encodeBase64(ciphertextBytes)\n  });\n}\n\nexports.trigger = function (pusher, channels, eventName, data, params) {\n  if (channels.length === 1 && util.isEncryptedChannel(channels[0])) {\n    const channel = channels[0];\n    const event = {\n      name: eventName,\n      data: encrypt(pusher, channel, data),\n      channels: [channel],\n      ...params\n    };\n    return pusher.post({\n      path: \"/events\",\n      body: event\n    });\n  } else {\n    for (let i = 0; i < channels.length; i++) {\n      if (util.isEncryptedChannel(channels[i])) {\n        // For rationale, see limitations of end-to-end encryption in the README\n        throw new Error(\"You cannot trigger to multiple channels when using encrypted channels\");\n      }\n    }\n\n    const event = {\n      name: eventName,\n      data: ensureJSON(data),\n      channels: channels,\n      ...params\n    };\n    return pusher.post({\n      path: \"/events\",\n      body: event\n    });\n  }\n};\n\nexports.triggerBatch = function (pusher, batch) {\n  for (let i = 0; i < batch.length; i++) {\n    batch[i].data = util.isEncryptedChannel(batch[i].channel) ? encrypt(pusher, batch[i].channel, batch[i].data) : ensureJSON(batch[i].data);\n  }\n\n  return pusher.post({\n    path: \"/batch_events\",\n    body: {\n      batch: batch\n    }\n  });\n};\n\nfunction ensureJSON(data) {\n  return typeof data === \"string\" ? data : JSON.stringify(data);\n}","map":{"version":3,"sources":["/media/amine/HDD1/Kraya/2DNI/TP/S2/Framework/Projet/IMessage-Clone/Frontend/node_modules/pusher/lib/events.js"],"names":["util","require","nacl","naclUtil","encrypt","pusher","channel","data","config","encryptionMasterKey","undefined","Error","nonceBytes","randomBytes","ciphertextBytes","secretbox","decodeUTF8","JSON","stringify","channelSharedSecret","nonce","encodeBase64","ciphertext","exports","trigger","channels","eventName","params","length","isEncryptedChannel","event","name","post","path","body","i","ensureJSON","triggerBatch","batch"],"mappings":"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","sourcesContent":["const util = require(\"./util\")\nconst nacl = require(\"tweetnacl\")\nconst naclUtil = require(\"tweetnacl-util\")\n\nfunction encrypt(pusher, channel, data) {\n  if (pusher.config.encryptionMasterKey === undefined) {\n    throw new Error(\n      \"Set encryptionMasterKey before triggering events on encrypted channels\"\n    )\n  }\n\n  const nonceBytes = nacl.randomBytes(24)\n\n  const ciphertextBytes = nacl.secretbox(\n    naclUtil.decodeUTF8(JSON.stringify(data)),\n    nonceBytes,\n    pusher.channelSharedSecret(channel)\n  )\n\n  return JSON.stringify({\n    nonce: naclUtil.encodeBase64(nonceBytes),\n    ciphertext: naclUtil.encodeBase64(ciphertextBytes),\n  })\n}\n\nexports.trigger = function (pusher, channels, eventName, data, params) {\n  if (channels.length === 1 && util.isEncryptedChannel(channels[0])) {\n    const channel = channels[0]\n    const event = {\n      name: eventName,\n      data: encrypt(pusher, channel, data),\n      channels: [channel],\n      ...params,\n    }\n    return pusher.post({ path: \"/events\", body: event })\n  } else {\n    for (let i = 0; i < channels.length; i++) {\n      if (util.isEncryptedChannel(channels[i])) {\n        // For rationale, see limitations of end-to-end encryption in the README\n        throw new Error(\n          \"You cannot trigger to multiple channels when using encrypted channels\"\n        )\n      }\n    }\n\n    const event = {\n      name: eventName,\n      data: ensureJSON(data),\n      channels: channels,\n      ...params,\n    }\n    return pusher.post({ path: \"/events\", body: event })\n  }\n}\n\nexports.triggerBatch = function (pusher, batch) {\n  for (let i = 0; i < batch.length; i++) {\n    batch[i].data = util.isEncryptedChannel(batch[i].channel)\n      ? encrypt(pusher, batch[i].channel, batch[i].data)\n      : ensureJSON(batch[i].data)\n  }\n  return pusher.post({ path: \"/batch_events\", body: { batch: batch } })\n}\n\nfunction ensureJSON(data) {\n  return typeof data === \"string\" ? data : JSON.stringify(data)\n}\n"]},"metadata":{},"sourceType":"script"}